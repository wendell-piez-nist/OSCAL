<?xml-model href="metaschema4.rnc" type="application/relax-ng-compact-syntax"?>
<?xml-model href="metaschema-check.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<METASCHEMA top="controls" use="control">

  <!-- The METASCHEMA  provides a means of developing and producing parallel XSD and JSON schemas
      from a single source, validating the same models in both syntaxes.
  It does this by defining "primitives" or "prototypes" that are then exploited by
  declarations which know how to bind them to appropriate data types. Since their behaviors
  are well-defined, these prototypes provide a framing structure from which an appropriate
  set of declarations (either for XML or for JSON data) may be expanded. The same
  declarations set can provide runtime configuration to conversion scripts that cast
  between XML and JSON equivalents.
  
  -->
<!--
  
  Uses / applications
    Schema generation (XSD, JSON schema, other) for mappable representations
    Produce conversion code
  -->

  <!-- type must be one of the following:
  field     - line of text w/ or w/o mixed inline content (as="mixed")
  component - mix of everything including maybe prose (once)
    (component was 'part')
  
  Design note: in some designs, an element 'p' might be produced as a line, supporting markdown in the JSON.
  But this doesn't support lists or preformatted blocks. For those, use a statement or prose inside a component
  
  -->

  <define-assembly name="control" group-as="controls">
      <flag name="class"/>
      <field required="yes" named="title"/>
      <fields named="prop" group-as="props"/>
      <assemblies named="param" group-as="params" address="id"/>
      <assemblies named="part" group-as="parts"/>
      <fields named="link" group-as="links"/>
      <!--<assemblies named="subcontrol" group-as="subcontrols" address="id"/>-->
      <assembly named="references"/>
    
  </define-assembly>

  <!--<define-cluster name="control" group-as="controls">
    <flag name="class"/>
    <cell required="yes" named="title"/>
    <cells named="prop" group-as="props"/>
    <clusters named="param" group-as="params" label="id"/>
    
    
    <clusters named="part" group-as="parts"/>
    <cells named="link" group-as="links"/>
    <!-\-<components declared-as="subcontrol"/>-\->
    <cluster named="references"/>
  </define-cluster>-->
  
  <define-field name="title" has-id="none" as="mixed"></define-field>

  <define-field name="prop" group-as="props">
    <flag name="class" required="yes"/>
  </define-field>

  <define-assembly group-as="params" name="param" address="id">
    <!-- when address-by is given a flag of that name is required: also
         a singleton constraint comes into play (must be the only assembly
         with that flag value among its siblings 
         <flag name="id" required="yes" datatype="ID"/>-->
    <flag name="class"/>
    <!-- should be label, desc* but the sample has it backward -->
    <fields      named="desc" group-as="descriptions"/>
    <field       named="label"/>
    <fields      named="requirement" group-as="requirements"/>
    <choice>
      <field     named="value"/>
      <assembly named="select"/>
    </choice>
    <fields named="link" group-as="links"/>
    <assemblies named="part" group-as="parts"/>
  </define-assembly>

  
<!-- key design q: is an entity a property of an object (such as a parameter belongs to a control)
     or is it a member of a sequence (array) contained in that object (such as a control in a group)
     So we promote param/@id to its label, but not control/@id (or don't we?)
     
     How, on the Schematron side, do we validate that IDs given as labels are unique (in document wide scope)?
     
  -->
  <define-field name="label" has-id="none" as="mixed"></define-field>

  <!-- @has-id = none on fields, when there are no attributes, permits
     us to produce a string (not an object) on the JSON side. -->
  <define-field name="desc" group-as="descriptions" has-id="none"  as="mixed"></define-field>

  <define-field name="requirement" group-as="requirements">
    <flag name="test"/>
  </define-field>

  <define-field name="value" has-id="none" as="mixed"></define-field>

  <define-assembly name="select">
    
    <flag name="how-many"/>
    <assemblies named="choice" group-as="alternatives"/>
  </define-assembly>

  <define-field name="choice" group-as="alternatives" as="mixed"></define-field>

  <define-assembly name="part" group-as="parts">
    <flag name="class"/>
    <field     named="title"/>
    <fields    named="prop" group-as="props"/>
    <prose/>
    <assemblies named="part" group-as="parts"/>
    <fields     named="link" group-as="links"/>
  </define-assembly>

  <define-field name="link" group-as="links" as="mixed">
    <flag name="href" datatype="anyURI"/>
    <flag name="rel"  datatype="NCName"/>
  </define-field>

  <define-assembly name="references">
    <assemblies group-as="refs" named="ref"/>
  </define-assembly>

  <define-assembly name="ref" group-as="refs">
    <fields group-as="citations" named="citation"/>
  </define-assembly>

  <!--<define-field as="mixed" group-as="citations" name="citation">
    <flag name="href" datatype="anyURI"/>
  </define-field>-->


  <define-field as="mixed" group-as="citations" name="citation">
    <flag name="href" datatype="anyURI"/>
  </define-field>
  
<!-- See metaschema-sketch4.xml for a full Metaschema including groups and subcontrols (but not declarations) -->

  <!--groups, controls and subcontrols are all components-->
  
  <define-assembly name="catalog" group-as="control-catalog">
    <field      named="title" required="yes"/>
    <assemblies named="section" group-as="sections"/>
    <choice>
      <assemblies named="group" group-as="groups"/>
      <assemblies named="control" group-as="controls"/>
    </choice>
    <assembly  named="references"/>
  </define-assembly>
  
  <!--<define-cell name="catalog" group-as="control-catalog">
    <cell      named="title" required="yes"/>
    <clusters named="section" group-as="sections"/>
    <choice>
      <clusters named="group" group-as="groups"/>
      <clusters named="control" group-as="controls"/>
    </choice>
    <cluster named="references"/>
  </define-cell>-->
  
  <define-assembly name="section" group-as="sections">
    <flag  name="class"/>
    <field      named="title" required="yes"/>
    <prose/>
    <assemblies named="section" group-as="sections"/>
    <assembly  named="references"/>
  </define-assembly>
  
  <define-assembly name="group" group-as="groups">
    <flag  name="class"/>
    <field      named="title" required="yes"/>
    <fields     named="prop"  group-as="props"/>
    <assemblies named="param" group-as="params" address="id"/>
    <assemblies named="part" group-as="parts"/>
    <choice>
      <assemblies named="group" group-as="groups"/>
      <assemblies named="control" group-as="controls"/>
    </choice>
    <assembly named="references"/>
  </define-assembly>
  
  <define-assembly name="subcontrol" group-as="subcontrols">
    <field      named="title" required="yes"/>
    <fields     named="prop"  group-as="props"/>
    <assemblies named="param" group-as="params" address="id"/>
    <assemblies named="part"  group-as="parts"/>
    <fields     named="link"  group-as="links"/>
    <assembly  named="references"/>
  </define-assembly>
  
  <!--<define-flag name="ID" datatype="ID" global="yes">
    <formal-name>ID</formal-name>
    <description>Unique identifier</description>
    <remarks>
      <p>Anything can get an ID</p>
    </remarks>
    
      <flag name="href" datatype="anyURI"/>
    
    <example>
      <citation xmlns="http://csrc.nist.gov/ns/oscal/1.0" href="somesiteurl.net">Some <strong>citation</strong> of some sort</citation>
    </example>
  </define-flag>
  
  <define-flag name="class" datatype="NMTOKEN"></define-flag>
  <define-flag name="href"  datatype="anyURI"></define-flag>-->
  
</METASCHEMA>
